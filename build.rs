use anyhow::{anyhow, bail};
use version_compare::Version;

const WARN: &str = "cargo::warning=";
const DIRTY_SUFFIX: &str = "-dirty";

fn main() -> anyhow::Result<()> {
    check_and_refine_package_versions()
}

/// - Checks that the package version is consistent bewteen:
///
///    - `Cargo.toml` (i.e. `$CARGO_PKG_VERSION`),
///    - `package.nix` (i.e. `$version`), and
///    - `git describe` (i.e. the latest git tag).
///
/// - Extends the package version, i.e. `$CARGO_PKG_VERSION` with a commit
///   hash suffix generated by `git describe`. This is useful for
///   identifying development builds.
///
/// This function should _not_ fail if there is no available git command or
/// git repository, which would be the case for a release build.
///
fn check_and_refine_package_versions() -> anyhow::Result<()> {
    println!("cargo::rerun-if-changed=.git");
    println!("cargo::rerun-if-env-changed=version");

    let set_version = |version: &str| {
        println!("{WARN}setting version to: {version}");
        println!("cargo::rustc-env=CARGO_PKG_VERSION={version}");
    };

    let version_from_cargo = env!("CARGO_PKG_VERSION");
    let version_from_nix = if let Some(version_from_nix) = option_env!("version") {
        if !version_from_nix.starts_with(version_from_cargo) {
            bail!(
                "inconsistent versioning: Cargo.toml={} vs package.nix={}\n{}\n{}",
                version_from_cargo,
                version_from_nix,
                "either update the versions or refresh the development environment",
                "if you are using direnv, prepend `watch_file Cargo.lock` to `.envrc`",
            );
        }
        version_from_nix
    } else {
        version_from_cargo
    };

    // we do not use `--long` up front in case we are exactly at a release tag
    let git_describe = "git describe --tags --match v* --abbrev=7 --dirty";
    let version_from_git = match run_command(git_describe) {
        Ok(desc) => desc.trim_start_matches('v').to_string(),
        Err(err) => {
            println!("{WARN}git-describe: {err}");
            println!("{WARN}`git` not installed? that's fine, moving on ...");
            set_version(version_from_nix);
            return Ok(());
        }
    };

    let version_from_git = if version_from_git.starts_with(version_from_cargo) {
        version_from_git
    } else {
        println!(
            "{WARN}inconsistent versioning: package={version_from_cargo} vs git={version_from_git}"
        );
        // ^ this is okay when e.g. the local git tags are stale

        let version_from_cargo = Version::from(version_from_cargo).unwrap();
        let version_from_git = Version::from(&version_from_git).unwrap();

        #[allow(clippy::redundant_else)]
        if version_from_cargo < version_from_git {
            bail!(
                "package version is older than git version!\n{}",
                "update the version in Cargo.toml to match the latest git tag"
            );
        } else {
            // this is okay, we are ahead of the latest git tag;
            // just rerun `git describe` with `--long`, which always includes
            // the commit hash:
            let cmd = format!("{git_describe} --long");
            run_command(&cmd)?
        }
    };

    let version_suffix = match version_from_git.rsplit_once("-g") {
        Some((_, short_rev)) => format!("-g{short_rev}"),
        None => match version_from_git.ends_with(DIRTY_SUFFIX) {
            true => DIRTY_SUFFIX,
            false => "",
        }
        .into(),
    };

    let version = format!("{version_from_cargo}{version_suffix}");
    set_version(&version);
    Ok(())
}

/// Runs a command and returns its stdout, or an error if the command fails.
fn run_command(cmd: &str) -> anyhow::Result<String> {
    let mut args = cmd.split_ascii_whitespace();
    let program = args.next().ok_or(anyhow!("bad command: {cmd}"))?;
    let err = format!("failed to run command: {cmd}");
    let output = std::process::Command::new(program).args(args).output()?;
    let stderr = String::from_utf8_lossy(&output.stderr);
    let stdout = String::from_utf8_lossy(&output.stdout);
    if !output.status.success() {
        bail!(
            "{err}\n stderr: {stderr}\n stdout: {stdout}\n status: {}",
            output.status
        );
    }
    if !stderr.trim().is_empty() {
        println!("{WARN}{cmd}: {stderr}");
    }
    Ok(stdout.trim().into())
}
