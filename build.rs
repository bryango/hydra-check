//! This build script extends the package version, i.e. `CARGO_PKG_VERSION`
//! with a commit hash suffix generated by `git describe`. This is useful for
//! identifying development builds.
//!
//! The script should never fail even if there is no available git command or
//! git repository, which would be the case for a release build.

const WARN: &str = "cargo::warning=";

fn main() {
    // we do not use `--long` up front in case we are exactly at a release tag
    let cmd = "git describe --tags --match v* --abbrev=7 --dirty";
    let desc = match run_command(cmd) {
        Ok(desc) => desc,
        Err(err) => {
            println!("{WARN}{err}");
            return;
        }
    };
    let desc = desc.trim_start_matches("v");

    let dirty_suffix = "-dirty";
    let pkg_version = env!("CARGO_PKG_VERSION");

    let desc = if !desc.starts_with(pkg_version) {
        println!("{WARN}inconsistent versioning: package={pkg_version} vs git={desc}");

        // rerun with `--long` which always includes the commit hash
        let cmd = format!("{cmd} --long");
        match run_command(&cmd) {
            Ok(desc) => desc,
            Err(err) => {
                println!("{WARN}{err}");
                return;
            }
        }
    } else {
        desc.to_string()
    };

    let version_suffix = match desc.rsplit_once("-g") {
        Some((_, short_rev)) => format!("-g{short_rev}"),
        None => match desc.ends_with(dirty_suffix) {
            true => dirty_suffix,
            false => "",
        }
        .into(),
    };

    println!("cargo::rustc-env=CARGO_PKG_VERSION={pkg_version}{version_suffix}");
    println!("cargo::rerun-if-changed=.git/index");
}

fn run_command(cmd: &str) -> Result<String, String> {
    let mut args = cmd.split_ascii_whitespace();
    let program = args.next().unwrap();
    let err = format!("failed to run command: {cmd}");
    let Ok(output) = std::process::Command::new(program).args(args).output() else {
        return Err(err);
    };
    let stderr = String::from_utf8_lossy(&output.stderr);
    let stdout = String::from_utf8_lossy(&output.stdout);
    if !output.status.success() {
        return Err(format!(
            "{err}\n stderr: {stderr}\n stdout: {stdout}\n status: {}",
            output.status
        ));
    }
    if !stderr.trim().is_empty() {
        println!("{WARN}{err}: {stderr}");
    }
    Ok(stdout.trim().into())
}
